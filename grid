.data
prompt_grid: .asciiz "\nCurrent Grid:\n"
card_back: .asciiz "[?] "
new_line: .asciiz "\n"
index_header: .asciiz "    0   1   2   3\n"

.text
.globl draw_grid
.extern card_states 16
.extern card_values 16

draw_grid:
    # Save registers
    addi $sp, $sp, -12
    sw $ra, 0($sp)
    sw $s0, 4($sp)
    sw $s1, 8($sp)

    # Print grid header
    li $v0, 4
    la $a0, prompt_grid
    syscall
    la $a0, index_header
    syscall

    # Initialize row counter
    li $s0, 0  # Row index

row_loop:
    bge $s0, 4, end_draw_grid  # Iterate through 4 rows

    # Print row number at the beginning of each row
    li $v0, 1
    move $a0, $s0
    syscall

    # Print space between row number and cards
    li $v0, 11
    li $a0, ' '
    syscall

    # Initialize column counter
    li $s1, 0  # Column index

col_loop:
    bge $s1, 4, next_row  # Iterate through 4 columns

    # Calculate card index: row * 4 + column
    mul $t0, $s0, 4
    add $t0, $t0, $s1  # t0 = row * 4 + col

    # Get card state from card_states array
    la $t1, card_states
    add $t2, $t1, $t0
    lb $t3, 0($t2)  # t3 = card state

    # If card is hidden, print [?]
    beq $t3, 0, print_hidden

    # Card is revealed or matched, print its value
    la $t1, card_values
    add $t2, $t1, $t0
    lb $a0, 0($t2)
    li $v0, 1
    syscall
    j end_print_card

print_hidden:
    # Print the hidden card symbol "[?]"
    li $v0, 4
    la $a0, card_back
    syscall

end_print_card:
    # Print space between cards
    li $v0, 11
    li $a0, ' '
    syscall

    # Move to next column
    addi $s1, $s1, 1
    j col_loop

next_row:
    # Print a newline at the end of each row
    li $v0, 4
    la $a0, new_line
    syscall

    # Move to next row
    addi $s0, $s0, 1
    j row_loop

end_draw_grid:
    # Restore registers
    lw $ra, 0($sp)
    lw $s0, 4($sp)
    lw $s1, 8($sp)
    addi $sp, $sp, 12
    jr $ra
