# grid.asm
# Draw a 4x4 grid for the Math Match game

    .data
prompt_grid: .asciiz "\nCurrent Grid:\n"
card_back: .asciiz "[?] "
new_line: .asciiz "\n"
index_header: .asciiz "    0   1   2   3\n"

    .text
    .globl draw_grid
    .extern card_states 8       # Declare card_states as external (8 bytes in size)
    .extern card_values 8       # Declare card_values as external (8 bytes in size)

draw_grid:
    # Save registers
    addi $sp, $sp, -12
    sw $ra, 0($sp)
    sw $s0, 4($sp)
    sw $s1, 8($sp)
    
    # Print grid header
    li $v0, 4
    la $a0, prompt_grid
    syscall
    la $a0, index_header
    syscall
    
    # Initialize row counter
    li $s0, 0                      # Row index

row_loop:
    bge $s0, 2, end_draw_grid      # Only two rows (8 cards total)
    
    # Print row number
    li $v0, 1
    move $a0, $s0
    syscall

    # Print space
    li $v0, 11
    li $a0, ' '
    syscall

    # Initialize column counter
    li $s1, 0                      # Column index

col_loop:
    bge $s1, 4, next_row           # Only 4 columns per row
    
    # Calculate card index
    mul $t0, $s0, 4
    add $t0, $t0, $s1              # t0 = row * 4 + col
    
    # Get card state
    la $t1, card_states
    add $t2, $t1, $t0
    lb $t3, 0($t2)                 # t3 = card state
    
    # If card is hidden, print [?]
    beq $t3, 0, print_hidden
    
    # Card is revealed or matched, print value
    la $t1, card_values
    add $t2, $t1, $t0
    lb $a0, 0($t2)
    li $v0, 1
    syscall
    j end_print_card

print_hidden:
    li $v0, 4
    la $a0, card_back
    syscall

end_print_card:
    # Print space between cards
    li $v0, 11
    li $a0, ' '
    syscall
    
    # Next column
    addi $s1, $s1, 1
    j col_loop

next_row:
    # Print newline
    li $v0, 4
    la $a0, new_line
    syscall
    
    # Next row
    addi $s0, $s0, 1
    j row_loop

end_draw_grid:
    # Restore registers
    lw $ra, 0($sp)
    lw $s0, 4($sp)
    lw $s1, 8($sp)
    addi $sp, $sp, 12
    jr $ra
